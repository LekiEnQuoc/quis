local Players = game:GetService("Players")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

local ARROW = workspace.senaahe585.Compasss.CompassArrow

-- tạo RaycastParams chỉ cho cây
local params = RaycastParams.new()
params.FilterType = Enum.RaycastFilterType.Whitelist
params.FilterDescendantsInstances = {workspace.Trees}

-- hướng tia (bỏ Y để chắc chắn la bàn không chỉ lên trời)
local dir = ARROW.CFrame.LookVector
dir = Vector3.new(dir.X, 0, dir.Z).Unit

local origin = ARROW.Position
local result = workspace:Raycast(origin, dir * 1000, params)

if not result then
	warn("Không có cây nào trúng tia")
	return
end

local hitPart = result.Instance
local tree = hitPart:FindFirstAncestorOfClass("Model")
if not tree then
	warn("Tia trúng nhưng không phải cây")
	return
end

-- lấy bounding box của cây
local cf, size = tree:GetBoundingBox()
local half = size * 0.5
local right, look = cf.RightVector, cf.LookVector
local center = cf.Position

-- 4 góc trên mặt đất
local corners = {
	center + right*half.X + look*half.Z,
	center - right*half.X + look*half.Z,
	center + right*half.X - look*half.Z,
	center - right*half.X - look*half.Z,
}

-- chọn góc gần hướng kim nhất
local bestCorner, bestDot = nil, -1
for _,corner in ipairs(corners) do
	local v = Vector3.new(corner.X-origin.X,0,corner.Z-origin.Z).Unit
	local d = v:Dot(dir)
	if d > bestDot then
		bestDot = d
		bestCorner = corner
	end
end

-- teleport nhân vật tới góc
if bestCorner then
	local offset = (bestCorner - center).Unit * 3
	local target = bestCorner + Vector3.new(0,3,0) + offset
	hrp.CFrame = CFrame.new(target, Vector3.new(bestCorner.X, target.Y, bestCorner.Z))
	print("Teleported to tree:", tree.Name, "corner:", bestCorner)
end
